<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Genarray (fftw3.Fftw3.S.Genarray)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../index.html">fftw3</a> &#x00BB; <a href="../../index.html">Fftw3</a> &#x00BB; <a href="../index.html">S</a> &#x00BB; Genarray</nav><header class="odoc-preamble"><h1>Module <code><span>S.Genarray</span></code></h1><p>FFT of Bigarray.Genarray.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value external" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.layout</span> <span class="arrow">&#45;&gt;</span></span> <span><span>int array</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Genarray.t</span></span></code></div><div class="spec-doc"><p>Creates a new array, just as <code>Bigarray.Genarray.create</code> does, but guarantees that it is aligned so one gets the better performance from FFTW.</p><p>Remark: In order to deserialize such a bigarray, this module must be linked to the program as the deserialization function also aligns the data.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-complex_array" class="anchored"><a href="#type-complex_array" class="anchor"></a><code><span><span class="keyword">type</span> <span>'l complex_array</span></span><span> = <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <a href="../index.html#type-complex_elt">complex_elt</a>, <span class="type-var">'l</span>)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Genarray.t</span></span></code></div><div class="spec-doc"><p>Double precision complex array.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-float_array" class="anchored"><a href="#type-float_array" class="anchor"></a><code><span><span class="keyword">type</span> <span>'l float_array</span></span><span> = <span><span>(float, <a href="../index.html#type-float_elt">float_elt</a>, <span class="type-var">'l</span>)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Genarray.t</span></span></code></div><div class="spec-doc"><p>Double precision float array.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-coord" class="anchored"><a href="#type-coord" class="anchor"></a><code><span><span class="keyword">type</span> coord</span><span> = <span>int array</span></span></code></div><div class="spec-doc"><p>Coordinates of elements or dimensions of an ND array (therefore the length of such an array of coordinates must be equal to the number of dimensions of the matrix).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dft" class="anchored"><a href="#val-dft" class="anchor"></a><code><span><span class="keyword">val</span> dft : <span><a href="../index.html#type-dir">dir</a> <span class="arrow">&#45;&gt;</span></span> <span>?meas:<a href="../index.html#type-measure">measure</a> <span class="arrow">&#45;&gt;</span></span> <span>?destroy_input:bool <span class="arrow">&#45;&gt;</span></span> <span>?unaligned:bool <span class="arrow">&#45;&gt;</span></span>
<span>?howmany_n:<span>int array</span> <span class="arrow">&#45;&gt;</span></span> <span>?howmanyi:<span><a href="#type-coord">coord</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>?ni:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?ofsi:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?inci:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'l</span> <a href="#type-complex_array">complex_array</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?howmanyo:<span><a href="#type-coord">coord</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>?no:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?ofso:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?inco:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'l</span> <a href="#type-complex_array">complex_array</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-c2c">c2c</a> <a href="../index.html#type-plan">plan</a></span></span></code></div><div class="spec-doc"><p><code>dft dir i o</code> returns a plan for computing the FFT in the direction <code>dir</code> from <code>i</code> to <code>o</code>. <code>i</code> and <code>o</code> must have the same number of (logical) dimensions and may be equal. If <code>i</code>, <code>ofsi</code> and <code>o</code>, <code>ofso</code> are respectively the same, the transform is done in-place. If not, the sub-matrices should not overlap. Raises <a href="../../module-type-Sig/index.html#exception-Failure"><code>Fftw3.Sig.Failure</code></a> if the plan cannot be created.</p><p>Note that FFTW computes an unnormalized DFT: computing a forward followed by a backward transform (or vice versa) results in the original array scaled by N, the product of the lofical dimensions <code>Array.fold_left ( * ) 1 ni
          = Array.fold_left ( * ) 1 no</code>.</p><ul><li><code>meas</code> controls how much time is dedicated to the creation of the plan. Default: <code>Measure</code>. <b>Beware</b> that, unless <code>~meas</code> is <code>Estimate</code>, creating a plan requires some trials that will destroy the content of the arrays.</li></ul><ul><li><code>destroy_input</code> specifies that an out-of-place transform may <i>overwrite its input</i> array. Overwriting input may sometimes allow more efficient algorithms to be employed. Default: <code>false</code> (i.e. perserve the content of the input array) except for c2r and HC2R.</li></ul><ul><li><code>unaligned</code> specifies that the algorithm may not impose any alignment requirements. You normally do not need this flag unless you want to use the plan with <i>other unaligned arrays</i> (using the guru interface). Default: <code>false</code> meaning that alignment may be used to speed up the computations (when <code>in</code> and <code>out</code> are aligned of course).</li></ul><p>Subarrays</p><p>Fftw3 allows you to perform the FFT transform on subarrays defined by offset, strides and dimensions. (Only the offset specification is dependent on the layout, the other two are the same regardless of whether the matrix has a C or FORTRAN layout.)</p><ul><li><code>ni</code> is the array with an entry for each dimension <code>k</code> of <code>i</code>. <code>ni.(k)</code> indicates how many increments <code>inci.(k)</code> we want to consider in the dimension <code>k</code>. Of course, the <code>ni.(k)</code> must be small enough so that the the subarrays fits in <code>i</code>, i.e., for all <code>k</code>, <code>ofsi.(k) + (ni.(k) - 1)
          abs(inci.(k))</code> must be <code>&lt; dim i k</code> (c_layout) or <code>&lt;= dim i k</code> (fortran_layout). If <code>ni.(k) = 0</code>, it means that we want the larger dimension <code>ni.(k)</code> that the choice of <code>ofsi.(k)</code> and <code>inci.(k)</code> allow. In this case, <code>ni.(k)</code> will be <i>overwritten</i> with the dimension that was automatically determined. Note that <code>ni.(k) = 1</code> means that the direction <code>k</code> is to be ignored (i.e. the <code>k</code>th index is constant with value <code>ofsi.(k)</code>).</li></ul><ul><li><code>ofsi</code> the initial element in the input array. Default: <code>[|0;...;0|]</code> for c_layout and <code>[|1;...;1|]</code> for fortran_layout.</li></ul><ul><li><code>inci</code> an array of increments for each (physical) dimension of the input array <code>i</code>. <code>inci.(k)</code> can be negative, indicating that the range <code>ofsi.(k)</code> .. <code>ofsi.(k) +
          (ni.(k) - 1) abs(inc.(k))</code> is traversed backward. This is the same behavior is as lacaml (LAPACK). If the increment <code>inci.(k) = 0</code>, that means that the dimension <code>k</code> must be ignored (i.e. the index in dimension <code>k</code> is constant with value <code>ofsi.(k)</code>). Default: <code>[|1;...;1|]</code>.</li></ul><ul><li><code>no</code> same as <code>ni</code> but for output. <code>no</code> must denote a transform of the same dimensions as <code>ni</code> i.e., neglecting the dimensions <code>1</code>, the two matrices must be the same.</li></ul><ul><li><code>ofso</code> same as <code>ofsi</code> but for output.</li></ul><ul><li><code>inco</code> same as <code>inci</code> but for output.</li></ul><p>For example, if one wants the submatrix indicated by the stars of the following (C layout) matrix:</p><pre>            a = [[x x x x x x     one sets:  ofs = [|1; 1|]
                  x * x * x x                inc = [|1; 2|]
 	          x * x * x x	             dim = [|2; 2|]
	          x x x x x x ]]</pre><p>The slice represented by the stars</p><pre>            a = [[x * x x x
                  x * x x x
                  x * x x x ]]</pre><p>is defined by <code>ofs = [|0; 1|]</code> and <code>inc = [|1; 0|]</code></p><p>Multiple transforms</p><p>FFTW allows to compute several transforms at once by specifying submatrices of <code>i</code> and <code>o</code>. This is more efficient than to create a different plan for each transform. It is your responsability to ensure that the many submatrices do not overlap.</p><ul><li><code>howmany_n</code> is an array of the (logical) dimensions of the array indexing the many transforms. Default: <code>[| |]</code>, i.e. only a single transform is performed. If <code>howmanyi</code> is given but no <code>howmany_n</code>, then the maximum dimensions possible by the dimensions of <code>i</code> (resp. <code>o</code>) are used. A value of <code>0</code> for a dimension also means to make it as large as possible.</li></ul><ul><li><code>howmanyi</code> is a list of vectors <code>[v1;...;vp]</code> generating the lattice of multiple arrays. In other words, if <code>a</code> is an element of (vector) index <code>k</code> in the &quot;first&quot; array, then the same element in the other arrays is at indices <code>k + i₁ *
          v1 + ... + iₚ * vp</code>. The dimension of each <code>vᵢ</code> must be equal to the number of dimensions of the input array <code>i</code>.</li></ul><ul><li><code>howmanyo</code> same as <code>howmanyi</code> but for output.</li></ul><p>For example, for the two subarrays are identified by * and +</p><pre>            a = [[x * + * +
                  x x x x x
                  x * + * +
                  x x x x x ]]</pre><p>one sets: <code>ofsi = [|0; 1|]</code>, <code>inci = [|2; 2|]</code> and <code>howmanyi
          = [ [|0; 1|] ]</code> (or <code>ofso</code>, <code>inco</code> and <code>howmanyo</code> if it is an output array).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-r2c" class="anchored"><a href="#val-r2c" class="anchor"></a><code><span><span class="keyword">val</span> r2c : <span>?meas:<a href="../index.html#type-measure">measure</a> <span class="arrow">&#45;&gt;</span></span> <span>?destroy_input:bool <span class="arrow">&#45;&gt;</span></span> <span>?unaligned:bool <span class="arrow">&#45;&gt;</span></span> <span>?howmany_n:<span>int array</span> <span class="arrow">&#45;&gt;</span></span>
<span>?howmanyi:<span><a href="#type-coord">coord</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>?ni:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?ofsi:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?inci:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'l</span> <a href="#type-float_array">float_array</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?howmanyo:<span><a href="#type-coord">coord</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>?no:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?ofso:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span>
<span>?inco:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'l</span> <a href="#type-complex_array">complex_array</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-r2c">r2c</a> <a href="../index.html#type-plan">plan</a></span></span></code></div><div class="spec-doc"><p><code>r2c i o</code> returns a plan for computing the <i>forward</i> transform from the real array <code>i</code> to the complex array <code>o</code>. Note that the last (for the C layout, or first for the fortran layout) dimension of <code>o</code> must be d/2+1 where d denotes the last dimension of <code>i</code>.</p><p>See <a href="../../module-type-Sig/Genarray/index.html#val-dft"><code>Fftw3.Sig.Genarray.dft</code></a> for the meaning of the other optional parameters.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-c2r" class="anchored"><a href="#val-c2r" class="anchor"></a><code><span><span class="keyword">val</span> c2r : <span>?meas:<a href="../index.html#type-measure">measure</a> <span class="arrow">&#45;&gt;</span></span> <span>?destroy_input:bool <span class="arrow">&#45;&gt;</span></span> <span>?unaligned:bool <span class="arrow">&#45;&gt;</span></span> <span>?howmany_n:<span>int array</span> <span class="arrow">&#45;&gt;</span></span>
<span>?howmanyi:<span><a href="#type-coord">coord</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>?ni:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?ofsi:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?inci:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'l</span> <a href="#type-complex_array">complex_array</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?howmanyo:<span><a href="#type-coord">coord</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>?no:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?ofso:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span>
<span>?inco:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'l</span> <a href="#type-float_array">float_array</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-c2r">c2r</a> <a href="../index.html#type-plan">plan</a></span></span></code></div><div class="spec-doc"><p><code>c2r i o</code> returns a plan for computing the <i>backward</i> transform from the complex array <code>i</code> to the complex array <code>o</code>. Note that, by default, executing the plan returned by <code>c2r</code> destroys the input array <code>i</code>. You can use <code>~destroy_input:false</code> to generate a plan that does not modify <code>i</code> at the expense of being slower — it is only possible in 1D and if no such plan can be created, <a href="../../module-type-Sig/index.html#exception-Failure"><code>Fftw3.Sig.Failure</code></a> is raised.</p><p>See <a href="../../module-type-Sig/Genarray/index.html#val-dft"><code>Fftw3.Sig.Genarray.dft</code></a> for the meaning of the other optional parameters.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-r2r" class="anchored"><a href="#val-r2r" class="anchor"></a><code><span><span class="keyword">val</span> r2r : <span><span><a href="../index.html#type-r2r_kind">r2r_kind</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span>?meas:<a href="../index.html#type-measure">measure</a> <span class="arrow">&#45;&gt;</span></span> <span>?destroy_input:bool <span class="arrow">&#45;&gt;</span></span> <span>?unaligned:bool <span class="arrow">&#45;&gt;</span></span>
<span>?howmany_n:<span>int array</span> <span class="arrow">&#45;&gt;</span></span> <span>?howmanyi:<span><a href="#type-coord">coord</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>?ni:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?ofsi:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?inci:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'l</span> <a href="#type-float_array">float_array</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?howmanyo:<span><a href="#type-coord">coord</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>?no:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?ofso:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span>?inco:<a href="#type-coord">coord</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'l</span> <a href="#type-float_array">float_array</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-r2r">r2r</a> <a href="../index.html#type-plan">plan</a></span></span></code></div><div class="spec-doc"><p><code>r2r kind i o</code> returns a plan for computing the transform from the complex array <code>i</code> to the complex array <code>o</code>. The type of transform along the dimension <code>k</code> is given by <code>kind.(k)</code> (you must give as many kinds as there are dimensions to the input array <code>i</code>).</p><p>Note that the default value of <code>destroy_input</code> is <code>false</code> but you may want to change it to <code>true</code>, especially in case one of the <a href="../index.html#type-r2r_kind"><code>r2r_kind</code></a> is <code>HC2R</code> in order to allow the use of more efficient algorithms. Try this if <a href="../../module-type-Sig/index.html#exception-Failure"><code>Fftw3.Sig.Failure</code></a> is raised.</p><p>See <a href="../../module-type-Sig/Genarray/index.html#val-dft"><code>Fftw3.Sig.Genarray.dft</code></a> for the meaning of optional parameters.</p></div></div></div></body></html>