<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>D (fftw3.Fftw3.D)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">fftw3</a> &#x00BB; <a href="../index.html">Fftw3</a> &#x00BB; D</nav><h1>Module <code>Fftw3.D</code></h1><p>Double precision FFTW.</p><nav class="toc"><ul><li><a href="#precision">Precision</a></li><li><a href="#specifying-plans">Specifying plans</a></li><li><a href="#executing-plans">Executing plans</a></li><li><a href="#creating-plans">Creating plans</a></li></ul></nav></header><section><header><h3 id="precision"><a href="#precision" class="anchor"></a>Precision</h3></header><dl><dt class="spec type" id="type-float_elt"><a href="#type-float_elt" class="anchor"></a><code><span class="keyword">type</span> float_elt</code><code> = Stdlib.Bigarray.float64_elt</code></dt><dd><p>Precision of float numbers.</p></dd></dl><dl><dt class="spec type" id="type-complex_elt"><a href="#type-complex_elt" class="anchor"></a><code><span class="keyword">type</span> complex_elt</code><code> = Stdlib.Bigarray.complex64_elt</code></dt><dd><p>Precision of complex numbers.</p></dd></dl><dl><dt class="spec value" id="val-float"><a href="#val-float" class="anchor"></a><code><span class="keyword">val</span> float : <span><span>(float, <a href="index.html#type-float_elt">float_elt</a>)</span> Stdlib.Bigarray.kind</span></code></dt><dd><p>Float of the precision of this module. Use this to create precision independent code.</p></dd></dl><dl><dt class="spec value" id="val-complex"><a href="#val-complex" class="anchor"></a><code><span class="keyword">val</span> complex : <span><span>(Stdlib.Complex.t, <a href="index.html#type-complex_elt">complex_elt</a>)</span> Stdlib.Bigarray.kind</span></code></dt><dd><p>Complex of the precision of this module. Use this to create precision independent code.</p></dd></dl></section><section><header><h3 id="specifying-plans"><a href="#specifying-plans" class="anchor"></a>Specifying plans</h3></header><dl><dt class="spec type" id="type-plan"><a href="#type-plan" class="anchor"></a><code><span class="keyword">type</span> <span>'a plan</span></code></dt><dd><p>FFTW plan.</p></dd></dl><dl><dt class="spec type" id="type-c2c"><a href="#type-c2c" class="anchor"></a><code><span class="keyword">type</span> c2c</code></dt><dd><p><code>c2c plan</code> usual discrete Fourier transform, from complex to complex</p></dd></dl><dl><dt class="spec type" id="type-r2c"><a href="#type-r2c" class="anchor"></a><code><span class="keyword">type</span> r2c</code></dt><dd><p><code>r2c plan</code> real to complex transform</p></dd></dl><dl><dt class="spec type" id="type-c2r"><a href="#type-c2r" class="anchor"></a><code><span class="keyword">type</span> c2r</code></dt><dd><p><code>c2r plan</code> complex to real transform</p></dd></dl><dl><dt class="spec type" id="type-r2r"><a href="#type-r2r" class="anchor"></a><code><span class="keyword">type</span> r2r</code></dt><dd><p><code>r2r plan</code> real to real transform</p></dd></dl><dl><dt class="spec type" id="type-dir"><a href="#type-dir" class="anchor"></a><code><span class="keyword">type</span> dir</code><code> = </code><table class="variant"><tr id="type-dir.Forward" class="anchored"><td class="def constructor"><a href="#type-dir.Forward" class="anchor"></a><code>| </code><code><span class="constructor">Forward</span></code></td></tr><tr id="type-dir.Backward" class="anchored"><td class="def constructor"><a href="#type-dir.Backward" class="anchor"></a><code>| </code><code><span class="constructor">Backward</span></code></td></tr></table></dt><dd><p>Direction of the transform — see the FFTW manual.</p></dd></dl><dl><dt class="spec type" id="type-measure"><a href="#type-measure" class="anchor"></a><code><span class="keyword">type</span> measure</code><code> = </code><table class="variant"><tr id="type-measure.Estimate" class="anchored"><td class="def constructor"><a href="#type-measure.Estimate" class="anchor"></a><code>| </code><code><span class="constructor">Estimate</span></code></td><td class="doc"><p>No measurements are made, use a simple heuristic to pick a (probably sub-optimal) plan quickly.</p></td></tr><tr id="type-measure.Measure" class="anchored"><td class="def constructor"><a href="#type-measure.Measure" class="anchor"></a><code>| </code><code><span class="constructor">Measure</span></code></td><td class="doc"><p>Find an optimized plan by actually computing several FFTs and measuring their execution time.</p></td></tr><tr id="type-measure.Patient" class="anchored"><td class="def constructor"><a href="#type-measure.Patient" class="anchor"></a><code>| </code><code><span class="constructor">Patient</span></code></td><td class="doc"><p>Like <code>Measure</code>, but considers a wider range of algorithms and often produces a &quot;more optimal&quot; plan at the expense of several times longer planning time.</p></td></tr><tr id="type-measure.Exhaustive" class="anchored"><td class="def constructor"><a href="#type-measure.Exhaustive" class="anchor"></a><code>| </code><code><span class="constructor">Exhaustive</span></code></td><td class="doc"><p>Like <code>Patient</code>, but considers an even wider range of algorithms, including many that are thought unlikely to be fast, to produce the most optimal plan but with a substantially increased planning time.</p></td></tr></table></dt><dd><p>Planning-rigor flags.</p></dd></dl><dl><dt class="spec type" id="type-r2r_kind"><a href="#type-r2r_kind" class="anchor"></a><code><span class="keyword">type</span> r2r_kind</code><code> = </code><table class="variant"><tr id="type-r2r_kind.R2HC" class="anchored"><td class="def constructor"><a href="#type-r2r_kind.R2HC" class="anchor"></a><code>| </code><code><span class="constructor">R2HC</span></code></td><td class="doc"><p>real to halfcomplex</p></td></tr><tr id="type-r2r_kind.HC2R" class="anchored"><td class="def constructor"><a href="#type-r2r_kind.HC2R" class="anchor"></a><code>| </code><code><span class="constructor">HC2R</span></code></td><td class="doc"><p>halfcomplex to real</p></td></tr><tr id="type-r2r_kind.DHT" class="anchored"><td class="def constructor"><a href="#type-r2r_kind.DHT" class="anchor"></a><code>| </code><code><span class="constructor">DHT</span></code></td><td class="doc"><p>discrete Hartley Transform</p></td></tr><tr id="type-r2r_kind.REDFT00" class="anchored"><td class="def constructor"><a href="#type-r2r_kind.REDFT00" class="anchor"></a><code>| </code><code><span class="constructor">REDFT00</span></code></td><td class="doc"><p>real-even DFT: even around j=0 and even around j=n-1</p></td></tr><tr id="type-r2r_kind.REDFT01" class="anchored"><td class="def constructor"><a href="#type-r2r_kind.REDFT01" class="anchor"></a><code>| </code><code><span class="constructor">REDFT01</span></code></td><td class="doc"><p>real-even DFT: even around j=0 and odd around j=n</p></td></tr><tr id="type-r2r_kind.REDFT10" class="anchored"><td class="def constructor"><a href="#type-r2r_kind.REDFT10" class="anchor"></a><code>| </code><code><span class="constructor">REDFT10</span></code></td><td class="doc"><p>real-even DFT: even around j=-0.5 and even around j=n-0.5</p></td></tr><tr id="type-r2r_kind.REDFT11" class="anchored"><td class="def constructor"><a href="#type-r2r_kind.REDFT11" class="anchor"></a><code>| </code><code><span class="constructor">REDFT11</span></code></td><td class="doc"><p>real-even DFT: even around j=-0.5 and odd around j=n-0.5</p></td></tr><tr id="type-r2r_kind.RODFT00" class="anchored"><td class="def constructor"><a href="#type-r2r_kind.RODFT00" class="anchor"></a><code>| </code><code><span class="constructor">RODFT00</span></code></td><td class="doc"><p>real-odd DFT; odd around j=-1 and odd around j=n</p></td></tr><tr id="type-r2r_kind.RODFT01" class="anchored"><td class="def constructor"><a href="#type-r2r_kind.RODFT01" class="anchor"></a><code>| </code><code><span class="constructor">RODFT01</span></code></td><td class="doc"><p>real-odd DFT; odd around j=-1 and even around j=n-1</p></td></tr><tr id="type-r2r_kind.RODFT10" class="anchored"><td class="def constructor"><a href="#type-r2r_kind.RODFT10" class="anchor"></a><code>| </code><code><span class="constructor">RODFT10</span></code></td><td class="doc"><p>real-odd DFT; odd around j=-0.5 and odd around j=n-0.5</p></td></tr><tr id="type-r2r_kind.RODFT11" class="anchored"><td class="def constructor"><a href="#type-r2r_kind.RODFT11" class="anchor"></a><code>| </code><code><span class="constructor">RODFT11</span></code></td><td class="doc"><p>real-odd DFT; odd around j=-0.5 and even around j=n-0.5</p></td></tr></table></dt><dd><p>Real-to-Real transform kinds. The real-even (resp. real-odd) DFT are somtimes called Discrete Cosine Transform (DCT) (resp. Discrete Sine Transform (DST)). Note that the explanations of the various transforms are for an <i>input</i> array of dimension <code>n</code> and C layout (i.e. the input array is <code>input[0..n-1]</code>). The logical size <code>N</code> is <code>N=2(n-1)</code> for <code>REDFT00</code>, <code>N=2(n+1)</code> for <code>RODFT00</code>, and <code>N=2n</code> otherwise. See the FFTW manual for more details.</p></dd></dl><dl><dt class="spec exception" id="exception-Failure"><a href="#exception-Failure" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Failure</span> <span class="keyword">of</span> string</code></dt><dd><p>Exception raised to indicate that a plan could not be created.</p></dd></dl></section><section><header><h3 id="executing-plans"><a href="#executing-plans" class="anchor"></a>Executing plans</h3></header><dl><dt class="spec value" id="val-exec"><a href="#val-exec" class="anchor"></a><code><span class="keyword">val</span> exec : <span><span class="type-var">'a</span> <a href="index.html#type-plan">plan</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>exec plan</code> executes the <code>plan</code> on the arrays given at the creation of this plan. This is the normal way to execute any kind of plan.</p><p>This function is thread safe (and may run the actual computation on a different core than the main program).</p></dd></dl><dl><dt class="spec module" id="module-Guru"><a href="#module-Guru" class="anchor"></a><code><span class="keyword">module</span> <a href="Guru/index.html">Guru</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Guru execution of plans.</p></dd></dl></section><section><header><h3 id="creating-plans"><a href="#creating-plans" class="anchor"></a>Creating plans</h3></header><dl><dt class="spec module" id="module-Genarray"><a href="#module-Genarray" class="anchor"></a><code><span class="keyword">module</span> <a href="Genarray/index.html">Genarray</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>FFT of Bigarray.Genarray.</p></dd></dl><dl><dt class="spec module" id="module-Array1"><a href="#module-Array1" class="anchor"></a><code><span class="keyword">module</span> <a href="Array1/index.html">Array1</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>FFT of Bigarray.Array1.</p></dd></dl><dl><dt class="spec module" id="module-Array2"><a href="#module-Array2" class="anchor"></a><code><span class="keyword">module</span> <a href="Array2/index.html">Array2</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>FFT of Bigarray.Array2.</p></dd></dl><dl><dt class="spec module" id="module-Array3"><a href="#module-Array3" class="anchor"></a><code><span class="keyword">module</span> <a href="Array3/index.html">Array3</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>FFT of Bigarray.Array3.</p></dd></dl></section></div></body></html>